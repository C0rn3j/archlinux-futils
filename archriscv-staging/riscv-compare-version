#!/usr/bin/python

from collections import defaultdict
import glob
import os
import pyalpm
import sys
import time

RVDBDIR = sys.argv[1]
REPOROOT = sys.argv[2]
PATCHREPO = sys.argv[3]

x86_handle = pyalpm.Handle(".", "/var/lib/pacman")
rv_handle = pyalpm.Handle(".", f"{RVDBDIR}")

rv_packages = defaultdict(dict)
x86_packages = defaultdict(dict)
pkgbase_map = defaultdict(set)

rv_provides = set()

version_mismatch = set()
db_mismatch = set()

blacklist = set()

with open(PATCHREPO + "/blacklist.txt") as f:
    for pkg in f:
        pkg = pkg.rstrip("\n")
        if pkg.startswith("#") or not pkg:
            continue
        blacklist.add(pkg)

print("""
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css" rel="stylesheet">
<style>tr:hover { background-color: #ddd !important; }</style>
<div class="table-responsive-sm"><table class="table table-sm table-hover">
<thead><tr><th scope="col">DB</th><th scope="col">Package</th><th scope="col">Status</th></tr></thead><tbody>
""")

def read_db(handle, db, result, build_pkgbase_map=False, check_duplicate=False):
    db_handle = handle.register_syncdb(db, 0)
    for package in db_handle.search(""):
        if check_duplicate and package.name in result:
            print(f"<tr><td>{db}</td><td>{package.name}</td><td><font color=red>Lint: package found in different repository: {result[package.name]['db']}.</font></td></tr>")
        for field in ("depends", "makedepends", "checkdepends", "provides", "arch", "base", "version"):
            result[package.name][field] = getattr(package, field)
        result[package.name]["db"] = db
        if build_pkgbase_map:
            pkgbase_map[result[package.name]["base"]].add(package.name)

for db in ["core", "extra", "community"]:
    read_db(x86_handle, db, x86_packages, build_pkgbase_map=True)
    read_db(rv_handle, db, rv_packages, check_duplicate=True)

rv_provides |= set(rv_packages)

for pkgname, package in rv_packages.copy().items():
    rvver = package["version"]

    if "." in rvver.split("-")[1]:
        rvver = "-".join((rvver.split("-")[0], rvver.split("-")[1].split(".")[0]))

    if pkgname in x86_packages:
        if rvver != x86_packages[pkgname]["version"]:
            version_mismatch.add(pkgname)

    for _package in package["provides"]:
        rv_provides.add(_package.split("=")[0])

def x86_history_link(package, db):
    if db in ["community"]:
        repo = 'community'
    elif db in ["core", "extra"]:
        repo = 'packages'
    else:
        repo = 'unsupported'
    return f"https://github.com/archlinux/svntogit-{repo}/commits/packages/{package}/trunk"

def patch_repo_link(package):
    if os.path.exists(f"{PATCHREPO}/{package}"):
        return f" <a href=https://github.com/felixonmars/archriscv-packages/tree/master/{package}><span class='badge bg-secondary'>patched</span></a>"
    else:
        return ""

def parse_build_log(log):
    stages = [
        ("patch failed", "\x1b[1m\x1b[32m==>\x1b[m\x0f\x1b[1m Applying RISC-V patches...\x1b[m\x0f"),
        ("source download failed", "\x1b[1m\x1b[31m==> ERROR:\x1b[m\x0f\x1b[1m Failure while downloading"),
        ("checksum mismatch", "\x1b[1m\x1b[31m==> ERROR:\x1b[m\x0f\x1b[1m One or more files did not pass the validity check"),
        ("gpg failed", "\x1b[1m\x1b[31m==> ERROR:\x1b[m\x0f\x1b[1m One or more PGP signatures"),
        ("dependency missing", "\x1b[?25h\x1b[1m\x1b[31m==> ERROR:\x1b[m\x0f\x1b[1m Could not resolve all dependencies"),
        ("dependency missing", "\x1b[1m\x1b[31m==> ERROR:\x1b[m\x0f\x1b[1m Could not resolve all dependencies."),
        ("prepare() failed", "\x1b[1m\x1b[31m==> ERROR:\x1b[m\x0f\x1b[1m A failure occurred in prepare()."),
        ("build() failed", "\x1b[1m\x1b[31m==> ERROR:\x1b[m\x0f\x1b[1m A failure occurred in build()."),
        ("check() failed", "\x1b[1m\x1b[31m==> ERROR:\x1b[m\x0f\x1b[1m A failure occurred in check()."),
        ("package() failed", "\x1b[1m\x1b[31m==> ERROR:\x1b[m\x0f\x1b[1m A failure occurred in package"),
        ("old config.guess", "configure: error: cannot guess build type; you must specify one"),
        ("broken rust target", "  error: Error loading target specification: Could not find specification for target \"riscv64-unknown-linux-gnu\".")
    ]
    last_failed_stage = None
    with open(log) as f:
        for line in f:
            for stage, prefix in stages.copy():
                if line.startswith(prefix):
                    last_failed_stage = stage
                    # Only check stages after the last failed stage for the following lines
                    for stage, prefix in stages.copy():
                        stages.remove((stage, prefix))
                        if stage == last_failed_stage:
                            break
    return last_failed_stage

broken_pkgs = set()
outdated_logs = set()
old_log_threshold = time.time() - 30 * 24 * 60 * 60
for pkgname, package in x86_packages.items():
    if os.path.exists(f"{REPOROOT}/.status/logs/{package['base']}"):
        if pkgname in rv_packages:
            rvver = rv_packages[pkgname]["version"]
            if "." in rvver.split("-")[1]:
                rvver = "-".join((rvver.split("-")[0], rvver.split("-")[1].split(".")[0]))
            if rvver == package["version"]:
                continue

        ftbfs_link = f"logs/{package['base']}/"
        log_marks = ""
        if os.path.isfile(f"{REPOROOT}/.status/logs/{package['base']}/{package['base']}-{package['version']}.log"):
            ftbfs_link = f"logs/{package['base']}/{package['base']}-{package['version']}.log"
            if os.path.getmtime(f"{REPOROOT}/.status/logs/{package['base']}/{package['base']}-{package['version']}.log") < old_log_threshold:
                log_marks += " <span class='badge bg-warning'>old</span>"
            failed_stage = parse_build_log(f"{REPOROOT}/.status/logs/{package['base']}/{package['base']}-{package['version']}.log")
            if failed_stage:
                log_marks += f" <span class='badge bg-danger'>{failed_stage}</span>"
        elif glob.glob(f"{REPOROOT}/.status/logs/{package['base']}/{package['base']}-{package['version']}-*.log"):
            log_marks += " <span class='badge bg-warning'>old format</span>"
        else:
            outdated_logs |= pkgbase_map[package['base']]
            continue

        pkgname_str = pkgname
        if pkgname != package['base']:
            pkgname_str += f" ({package['base']})"

        print(f"<tr><td>{package['db']}</td><td>{pkgname_str}</td><td><a href='{ftbfs_link}'>"
              f"<font color=red>FTBFS</font></a>{log_marks + patch_repo_link(package['base'])}</td></tr>")
        broken_pkgs.add(pkgname)

def missing_dep(pkgbase):
    check_pkgs = set()
    for pkgname in pkgbase_map[pkgbase]:
        package = x86_packages[pkgname]
        check_pkgs |= set(package["depends"] + package["makedepends"] + package["checkdepends"])
    for dep in check_pkgs:
        for _c in "<", ">", "=":
            dep = dep.split(_c)[0]
        if dep not in rv_provides and dep not in pkgbase_map[pkgbase]:
            return dep

    return False

for pkgname in sorted(version_mismatch):
    if pkgname in broken_pkgs:
        continue
    db = x86_packages[pkgname]['db']
    pkgbase = x86_packages[pkgname]['base']
    rvver = rv_packages[pkgname]["version"]
    x86ver = x86_packages[pkgname]['version']
    cmp = pyalpm.vercmp(rvver, x86ver)
    if cmp < 0:
        rvpkgver = rvver.split("-")[0]
        x86pkgver = x86ver.split("-")[0]
        if rvpkgver == x86pkgver:
            rvpkgrel = rvver.split("-")[1]
            x86pkgrel = x86ver.split("-")[1]
            verstr = f"{rvpkgver}-<font color=green>{rvpkgrel} -> </font>{x86pkgver}-<font color=green>{x86pkgrel}</font>"
        else:
            verstr = f"<font color=green>{rvver} -> {x86ver}</font>"
    elif cmp > 0:
        verstr = f"<font color=yellow>{rvver} <- {x86ver}</font>"
    verstr += f" <a href={x86_history_link(pkgbase, db)}>Changes</a>"

    dep = missing_dep(pkgbase)
    if dep:
        verstr += f" <font color=red>Dependency '{dep}' not satisfied.</font>"

    if pkgname in outdated_logs:
        verstr += f" <a href='logs/{pkgbase}/'><font color=yellow>(Outdated FTBFS Logs)</font></a>"

    verstr += patch_repo_link(pkgbase)

    pkgname_str = pkgname
    if pkgname != pkgbase:
        pkgname_str += f" ({pkgbase})"

    print(f"<tr><td>{db}</td><td>{pkgname_str}</td><td>{verstr}</td></tr>")

for pkgname, package in x86_packages.items():
    if pkgname in rv_packages or pkgname in broken_pkgs or pkgname in blacklist:
        continue

    pkgname_str = pkgname
    if pkgname != package['base']:
        pkgname_str += f" ({package['base']})"

    dep = missing_dep(package['base'])
    if dep:
        print(f"<tr><td>{package['db']}</td><td>{pkgname_str}</td><td><font color=red>Dependency '{dep}' not satisfied.</font></td></tr>")
    else:
        verstr = "Leaf package, port it!"
        if pkgname in outdated_logs:
            verstr += f" <a href='logs/{package['base']}/'><font color=yellow>(Outdated FTBFS Logs)</font></a>"
        verstr += patch_repo_link(package['base'])
        print(f"<tr><td>{package['db']}</td><td>{pkgname_str}</td><td>{verstr}</td></tr>")

for pkgname, package in rv_packages.items():
    if pkgname not in x86_packages:
        print(f"<tr><td>{package['db']}</td><td>{pkgname}</td><td><font color=yellow>Lint: package not found in x86 repository.</font></td></tr>")
    elif x86_packages[pkgname]["db"] != package["db"]:
        print(f"<tr><td>{package['db']}</td><td>{pkgname}</td><td><font color=red>Lint: package in different x86 repository: {x86_packages[pkgname]['db']}.</font></td></tr>")

print('</tbody></table></div>')
