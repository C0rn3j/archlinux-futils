#!/usr/bin/python
import argparse
import logging
from collections import defaultdict
import networkx as nx
import pyalpm

# TODO: Automate this. The packages listed here depend on ghc/ghc-libs but don't have .so files.
HASKELL_DO_NOT_EXPAND = {
    'alex',
    'c2hs',
    'cabal-install',
    'cgrep',
    'git-annex',
    'git-repair',
    'happy',
    'hedgewars',
    'hopenpgp-tools',
    'tamarin-prover',
    'uusi',
    'xmonad-utils',
}

parser = argparse.ArgumentParser(description='Rebuild generator and orderer, generates all haskell reverse deps too')
parser.add_argument('-H', '--haskell-check', action="store_true",
                                             help='Filter results for haskell-only rebuilds, also implies --expand, --expand-make, --expand-check')
parser.add_argument('-e', '--expand', action="store_true",
                                      help='Expand all reverse deps')
parser.add_argument('-m', '--expand-make', action="store_true",
                                           help='Expand all reverse make deps')
parser.add_argument('-c', '--expand-check', action="store_true",
                                            help='Expand all reverse check deps')
parser.add_argument('package', nargs='+', help='Packages to rebuild')
args = parser.parse_args()

if args.haskell_check:
    args.expand = True
    args.expand_make = True
    args.expand_check = True

logging.basicConfig(format="%(message)s", level=logging.INFO)
rebuild_list = set(args.package)

package_db = defaultdict(dict)
pkglist = rebuild_list.copy()
reverse_deps = defaultdict(set)
G = nx.DiGraph()
handle = pyalpm.Handle(".", "/var/lib/pacman")

for db in ["core", "extra", "community", "multilib"]:
    db_handle = handle.register_syncdb(db, 0)
    for package in db_handle.search(""):
        for field in ("depends", "makedepends", "checkdepends", "arch"):
            package_db[package.name][field] = getattr(package, field)

for pkg in package_db:
    package_db[pkg]["depends"] = {dep.split("=")[0].split(">")[0].split("<")[0] for dep in package_db[pkg]["depends"]}
    package_db[pkg]["makedepends"] = {dep.split("=")[0].split(">")[0].split("<")[0] for dep in package_db[pkg]["makedepends"]}
    package_db[pkg]["checkdepends"] = {dep.split("=")[0].split(">")[0].split("<")[0] for dep in package_db[pkg]["checkdepends"]}


def resolve_pkg(pkg):
    newpkgs = set()
    if pkg not in reverse_deps:
        if args.haskell_check and (not ({"ghc", "ghc-libs"} & set(package_db[pkg]["depends"]) and package_db[pkg]["arch"] != "any")):
           return reverse_deps[pkg]

        for _pkg in package_db:
            if args.haskell_check and not ({"ghc", "ghc-libs"} & set(package_db[_pkg]["depends"]) and package_db[_pkg]["arch"] != "any"):
                continue
            if pkg in package_db[_pkg]["depends"] or pkg in package_db[_pkg]["makedepends"] or \
               pkg in package_db[_pkg]["checkdepends"]:
                reverse_deps[pkg].add(_pkg)
                if args.haskell_check and pkg in HASKELL_DO_NOT_EXPAND:
                    pass
                else:
                    if args.expand and pkg in package_db[_pkg]["depends"]:
                        newpkgs.add(_pkg)
                    if args.expand_make and pkg in package_db[_pkg]["makedepends"]:
                        newpkgs.add(_pkg)
                    if args.expand_check and pkg in package_db[_pkg]["checkdepends"]:
                        newpkgs.add(_pkg)

    # Handle empty gracefully
    reverse_deps[pkg]
    return newpkgs


# Expand reverse dependencies
while len(pkglist) != len(reverse_deps):
    for pkg in list(pkglist):
        if pkg not in reverse_deps:
            pkglist |= resolve_pkg(pkg)


G.add_nodes_from(reverse_deps.keys())
for dep, pkgs in reverse_deps.items():
    for pkg in pkgs:
        if pkg in pkglist:
            G.add_edge(dep, pkg)


def decycle(nocheck_pkg, cycle):
    # A <=> B, decycle (A <= B), result: B:nocheck <= A <= B
    # Create B:nocheck, Remove B <= A, Add B:nocheck <= A
    new_pkg = nocheck_pkg + ":nocheck"
    package_db[new_pkg] = package_db[nocheck_pkg]
    for dep in package_db[new_pkg]["depends"]:
        if dep in pkglist:
            G.add_edge(dep, new_pkg)
    for edge in cycle:
        if edge[0] == nocheck_pkg:
            G.remove_edge(nocheck_pkg, edge[1])
            G.add_edge(new_pkg, edge[1])


while True:
    try:
        cycle = nx.find_cycle(G)
        cycle_pkgs = set()
        for edge in cycle:
            cycle_pkgs |= set(edge)
        logging.info("Found circular dependency: " + str(cycle_pkgs))
        for edge in cycle:
            if edge[0] not in package_db[edge[1]]["depends"] and not edge[0].endswith(":nocheck"):
                logging.info("Removing soft dep to solve circular dependency: " + "<-".join(edge))
                decycle(edge[1], cycle)
                break
        else:
            logging.info("!!! Removing HARD dep to solve circular dependency: " + "<-".join(edge))
            G.remove_edge(*edge)

    except nx.exception.NetworkXNoCycle:
        break

print(" ".join(nx.lexicographical_topological_sort(G)))
